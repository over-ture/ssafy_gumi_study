
# [BOJ] 2178 - 미로탐색 (Java)

## 🔗 문제 링크
[백준 2178번: 미로탐색](https://www.acmicpc.net/problem/2178)


---
## 📊 성능 분석 (Performance)

| 메모리 (Memory) | 시간 (Time) | 언어 (Language) | 코드 길이 (Code Length) |
| :---: | :---: | :---: | :---: |
| **14396 KB** | **120 ms** | **Java 11** | **2308 B** |


## 📌 문제 개요
$N \times M$ 크기의 미로에서 시작점(좌측 상단)부터 도착점(우측 하단)까지 이동하는 최단 거리를 구하는 문제입니다. 만약 도착점에 도달할 수 없다면 -1을 반환합니다.


---

## 💡 해결 프로세스
 1. 좌표 복원 및 4방향 탐색: 큐(Queue)에서 현재 위치(1차원 인덱스)를 꺼낸 뒤, 열의 크기($M$)를 활용한 몫과 나머지 연산으로 2차원 좌표(행, 열)로 복원하여    상하좌우 이동을 계산합니다.
 2. 사전 검사 (Pre-test) 및 가지치기:
    * 이동할 좌표가 미로 범위를 벗어났는지(OOB) 확인합니다.
    * 이동할 곳이 벽('0')이거나, 이미 더 짧은(혹은 같은) 거리로 방문한 적이 있는지 확인하여 건너뜁니다.
 3. 거리 갱신 및 종료: 다음 위치를 큐에 넣고 거리를 갱신하며, 도착점 인덱스($N \times M - 1$)에 도달하면 즉시 누적 거리를 반환합니다.



---

## 💻 코드 구조 상세 (Core Logic)

🔍 2차원 데이터를 1차원 배열로 평탄화 (입력)
```Java
// 2차원 배열은 행마다 주소가 달라 캐시 지역성을 누리기 힘듦  int[R]-> 하나의 '객체'
// 0 ~ (N*M - 1) 1차원 인덱스로 대응하여 '물리적 연속성' 확보
for(int i = 0 ; i < n; ++i) {
    line = br.readLine();
    for(int j = 0; j < m; ++j) {
        laby[i * m + j] = line.charAt(j); 
    }
}
```
🗺️ 1차원 인덱스를 2차원 좌표로 복원 (탐색)
```Java
int nr = (now / m) + dr[k];
int nc = (now % m) + dc[k];
// OOB 유효성 검사 및 다음 위치의 1차원 변환에 이용...
/* 다음 위치의 2차원 좌표를 다시 1차원 인덱스로 변환 */
int next = nr * m + nc;
```
✅ 유효성 검사 및 최단 거리 갱신 로직

```Java
/* OOB(Out of Bounds) 테스트 */
if(nr < 0 || nr >= n || nc < 0 || nc >= m) continue;

/* 벽('0')이거나, 기존에 방문한 거리보다 크거나 같으면 패스  */
if(laby[next] == '0' || dist[next] <= dist[now] + 1) continue;
// 최단 거리 갱신
dist[next] = dist[now] + 1; 
que.add(next);
```

---
⚠️ 주의 및 회고
 생각보다 평탄화로 인한 효과는 크지 않았음,  QUEUE가 받는 템플릿(제네릭) 인자 타입의 박싱과 언박싱, 및 모듈러 연산 때문에 느린 것 같다. 
