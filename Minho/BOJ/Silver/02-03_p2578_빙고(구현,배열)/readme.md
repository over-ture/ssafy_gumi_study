[BOJ] 2578 - 빙고 (Java)📌 문제 개요5x5 크기의 빙고판에 숫자가 적혀 있고, 사회자가 숫자를 하나씩 부릅니다. 가로, 세로, 대각선 방향으로 5개의 숫자가 모두 선이 그어지면 '빙고'가 성립하며, 3개 이상의 빙고가 완성되는 즉시 사회자가 몇 번째 숫자를 불렀는지 출력하는 프로그램을 작성합니다.💡 주요 설계 및 로직1. 효율적인 위치 조회 (Pair[] cache)빙고판에서 매번 숫자를 검색하는 비효율을 방지하기 위해, 숫자의 좌표를 사전에 저장하는 캐싱 기술을 사용합니다.cache[숫자] = new Pair(행, 열)사회자가 숫자를 부를 때마다 즉시 좌표(r, c)를 얻어낼 수 있습니다.2. 빙고 카운팅 최적화전체 빙고판을 매번 전수조사하는 대신, 각 행/열/대각선의 체크된 개수를 기록하는 배열과 변수를 사용합니다.row[5], col[5]: 각 행과 열에 체크된 숫자의 개수를 누적.crossD: 하향 대각선 ($r == c$)의 체크 개수.crossU: 상향 대각선 ($r + c == 4$)의 체크 개수.3. 빙고 판별 알고리즘숫자가 불릴 때마다 check() 함수를 호출하여 현재 완성된 빙고 줄의 개수를 합산합니다.누적 배열의 값이 5가 되면 한 줄의 빙고가 완성된 것입니다.완성된 빙고 줄(ans)이 3개 이상이면 게임을 종료합니다.💻 코드 구조 상세주요 변수변수명타입설명bingoint[][]5x5 빙고판 숫자 정보row / colint[]각 행/열별 체크된 숫자 개수 관리crossU / crossDint상향/하향 대각선 체크된 숫자 개수 관리cachePair[]숫자별 좌표(x, y)를 저장하는 인덱스 배열핵심 로직 Flow입력 단계: 빙고판의 숫자를 읽으며 cache 배열에 각 숫자의 위치를 저장합니다.진행 단계: 사회자가 부르는 숫자를 하나씩 가져옵니다.마킹 단계: cache에서 좌표를 찾아 해당 행, 열, 대각선 카운트 변수를 +1 합니다.판별 단계: check()를 통해 빙고 줄이 3개 이상인지 검사합니다.종료 단계: 조건을 만족하면 현재까지 불린 숫자의 총 개수(1 + i*5 + j)를 출력하고 프로그램을 종료합니다.📝 코드 주석 가이드 (요약)Java// 숫자를 부를 때마다 좌표를 O(1)에 찾기 위한 캐시 사용
cache[bingo[i][j]] = new Pair(i, j);

// 사회자가 숫자를 부르면 해당 라인들의 카운트를 증가
++row[r];
++col[c];
if(r == c) ++crossD;  
if((5 - 1) == r + c) ++crossU;

// 빙고 개수가 3개 이상인지 매번 체크
if(check()) {
    bw.write(1 + i * 5 + j + ""); // 몇 번째 숫자인지 계산 후 출력
    return;
}
🚀 추가 제언좌표 값 주의: 코드 내 Pair 클래스 생성자에서 (y, x) 순서로 인자를 받고 있으므로, 할당 시 행(r)과 열(c)의 매핑이 뒤바뀌지 않도록 주의해야 합니다.조기 종료: 빙고는 최소 12개 이상의 숫자가 불려야 3줄이 완성될 수 있으나, 본 코드는 안전하게 매 숫자마다 체크를 수행하고 있습니다.