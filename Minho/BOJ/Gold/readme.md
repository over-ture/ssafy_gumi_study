
# [BOJ] 9935 - 문자열폭발 (Java)

## 🔗 문제 링크
[백준 9935번: 문자열 폭발](https://www.acmicpc.net/problem/9935)


---
## 📊 성능 분석 (Performance)

| 메모리 (Memory) | 시간 (Time) | 언어 (Language) | 코드 길이 (Code Length) |
| :---: | :---: | :---: | :---: |
| **25516 KB** | **328 ms** | **Java 11** | **1661 B** |


## 📌 문제 개요
$N 크기의 문자열과 포발 문자열이 주어집니다. 연속된 부분 문자열이 폭발 문자열에 해당하면 폭발문자열을 제외한 나머지 문자열을 이어 붙입니다.<br>새로 생긴 문자열에는 폭발 문자열이 포함되어 있을 수 있습니다. 폭발문자열이 더이상 포함되어있지 않을 때의 문자열을 출력하세요 


---

## 💡 해결 프로세스
 1. 스택은 배열로 표현하였습니다. top은 int 형의 인덱스로 나타냅니다.
 2. 주어진 문자열을 순회하면서 현재 조사중인 문자를 스택에 넣습니다.
 3. 문자 하나를 읽은 후, 스택의 크기가 폭발 문자열보다 크거나 같다면 스택의 top부터 거꾸로 폭발 문자열이 완성되었는지 확인합니다.
 4. 확인 후, 폭발을 한다면 top(index)를 조정하여 스택에서 폭발 문자열을 지웁니다.(연쇄 폭발은 다음 문자를 읽어야 알 수 있습니다.) 

---

## 💻 코드 구조 상세 (Core Logic)

🔍 뒤에서 m-1 개 만큼 n-m 번째 노드에 연결
```Java
     for (int i = 0; i < line.length(); i++) {
            // 1. 무조건 스택에 넣는다
            stack[nowTop++] = line.charAt(i);
            
            // 2. 스택의 길이가 폭발 문자열 길이 이상일 때만 검사
            if (nowTop >= bombSize) {
                boolean isBomb = true;
                
                // 스택의 Top 부분과 폭발 문자열을 비교
                for (int j = 0; j < bombSize; j++) {
                    if (stack[nowTop - bombSize + j] != bomb.charAt(j)) {
                        isBomb = false;
                        break;
                    }
                }
                
                // 3. 폭발 문자열이면 포인터만 내린다 (자연스러운 삭제 및 상태 롤백)
                if (isBomb) {
                    nowTop -= bombSize;
                }
            }
```


---
⚠️ 주의 및 회고
 풀이를 생각하는데 시간이 상당히 걸렸다. 앞으로 시간복잡도를 잘 확인하여 2중 for문 풀이를 빨리 생각해냈으면 좋겠다.
